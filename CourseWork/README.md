# Reverse polish calculator

## About program

* Поддерживаемый тип данных: вещественные числа (double)

* Поддерживаемые знаки: +, -, *, /, ^, унарный “-”.
* Поддерживаемые функции с одним аргументом: cos, sin, tg, ctg, ln, log, sqrt, cbrt.
* Поддерживаемые константы: pi, e 
* Other: "(", ")"

### What it program can?

>Осуществляет проверку на корректность скобок в выражении:
* Совпадает ли количество открытых и закрытых скобок
* Находится ли откр. скобка левее закр. скобки
* Находится ли в каждой скобке выражение?(Проверка на пустоту)
  
>Осуществляет проверку на корректность написания названия функции

>Осуществляет проверку на корректность аргумента внутри функции (является ли аргумент числом)

>В случае недостаточного количества операндов, выводит соответствующее сообщение

>Указывает пользователю момент в выражении, в котором допущена ошибка

>Переводит введеное выражение в постфиксную нотацию

>Вычисляет введеное выражение

### Description of the data structures used

В решении данной задачи используется двусвязный список с принципом работы как у стека, из-за удобства хранения в нем отдельных частей выражения, а также последующей проверки их на корректность. Кроме этого, в основе работы обратной польской нотации лежит именно стек

Помимо стека в программе присутствует итератор для стека, из-за необходимости просматривать стек с постфиксной записью как обычный список (с начала и до конца), не взаимодействуя с самим стеком

### Algorythm
- Вводим выражение(строку)
- Изначально проверяем данное выражение на корректность расстановки скобок
- Перед разделением строки удаляем все повторяющиеся пробелы, а также пробелы в конце и начале выражения
- Делим входное выражение на отдельные части(токен), используя в качестве разделителя знак " ", и помещаем их в стек 
- Проверяем каждый токен в стеке на корректность ввода:
    - Является ли токен одним из оператов (+-/*)
    - Является ли токен числом
    - Является ли токен константой (pi, e)
    - Является ли токен функцией
    - Если токен не является ничем вышеперечисленным, тогда выводится текущий токен и выбрасывается исключение. Таким образом, пользователь может увидеть в какой части он допустил ошибку
- Происходит конвертация в постфиксную нотацию, после чего она выводится в консоль
- Происходит вычисление выражения по постфиксной нотации, после чего результат выводится в консоль

### Description of algorithms

> Проверка количества скобок

**bool checkCountBracket(const std::string &str)**

Итерируем строку

При каждой итерации увеличивается счетчик той или иной скобки, если она совпала с текущим символом

Возвращается результат сравнения счетчиков количества "(" и ")" в строке

> Проверка на пустые скобки

**bool checkEmptyBracket(const std::string &str)**

Изначально заводим переменную balance со значением 0, которая будет отвечать за соотношение "(" и ")"

Итерируем строку

Если текущий символ является "(", увеличиваем balance на единицу

Если текущий символ является ")", уменьшаем balance на единицу

Если balance стал отрицательным, то это свидетельствует о том, что закрывающихся скобок в один момент в строке было больше открывающихся, чего быть не должно, а значит возвращаем false

Если balance на протяжении всей итерации был больше 0, тогда возвращаем true

> Проверка на соответсвие скобок

**bool checkMatchingBracket(const std::string &str)**

Итерируем строку 

Если текущий символ является "(", тогда пропускаем все пробелы до следующего символа

Если символ, на котором остановился итератор является ")", тогда возвращаем false

По окончании итерации возвращаем true

> Удаление повторяющихся пробелов

**void remDupSpaces(std::string &str)**

Удаляем все пробелы до первого символа в строке

Удаляем все пробелы с конца строки до первого символа

Итерируем строку

Удаляем подстроку длиной больше единицы, состоящую исключительно из пробелов, оставляя один символ. Таким образом, мы получаем строку с единичными пробелами между будущими токенами

> Деление строки на токены


**Stack parse(std::string &str)**

Заводим стек

Заводим отдельную переменную, в которой будем хранить текущий токен

Итерируем строку

Если текущий символ является пробелом, тогда добавляем значение нашей переменной в стек и очищаем ее, иначе добавляем текущий символ в конец нашей переменной

Если в конце итераций у нас что-то осталось в переменной, тогда добавляем ее значение в стек

Возвращаем стек с токенами

> Проверка на принадлежность к операндам
> 
**bool isDigit(const std::string &str)**

Проверка на наличие только одной точки в числе

Проверка положения точки(она не должна быть первым или последним символом)

Проверка ситуации, когда в строке находится только минус без числа

Проверка на наличие только одного минуса в числе

Проверка положения минуса(он может быть только первым символом в числе)

Возвращаем результат сравнения нахождения иных символов(не числа, точки или минуса) и нахождения числа, точки или минуса. Таким образом, мы проверяем отсутствие лишних символов кроме числа

> Проверка на принадлежность к функциям

**bool isFunc(const std::string &str)**

Копируем переданную строку в отдельную переменную

Если первый символ является минусом, тогда убираем его

Итерируем строку

Если переданная строка содержит в себе хотя бы одну функцию из списка, тогда оставляем только аргумент внутри функции, чтобы проверить его на число

Если строка содержит больше одной функции, возвращаем false

Возвращаем результат проверки аргумент функции на число или константу

> Проверка на принадлежность к операторам

**bool isOperator(const std::string &str)**

Если переданная строка полностью совпадает с одним из операторов, возвращаем true

Иначе возвращаем false

> Проверка на принадлежность к константам

**bool isConst(const string &str)**

Если переданная строка полностью совпадает с одной из констант со знаком "минус" или без, возвращаем true

Иначе возвращаем false

> Проверка каждого токена отдельно

**void checkTokens(const Stack &tokens)**

Проходимся по каждому элементу стека начиная сначала, благодаря итератору

Если токен не является оператором, числом, константой, функцией или одной из скобок, тогда выводим отдельно этот токен и выбрасываем исключение, чтобы пользователь мог понять где находится ошибка

> Получение приоритета токена(для скобок и операндов)

**size_t getPrioritet(const std::string &str)**

Если строка является одной из скобок, возвращаем 0

Если строка является "+" или "-", возвращаем 1

Если строка является "*" или "/", возвращаем 2

Иначе выбрасываем исключение

> Конвертация в постфиксную нотацию

**Stack convertToPostfix(Stack &tokens)**

Итерируем наш стек с токенами

Если просматриваемый токен - операнд, то помещаем в выходной поток

Если просматриваемый токен - оператор

Если приоритет оператора, который находится наверху стека, 
больше или равен приоритета токена

Тогда пока не увидим оператор с меньшим приоритетом,
извлекаем все операторы из стека в выходной поток

Затем помещаем просматриваемый оператор в стек

Иначе помещаем просматриваемый оператор в стек сразу

Если просматриваемый токен - левая скобка

Добавляем в конец стек токен

Если просматриваемый токен - правая скобка

Извлекаем из стека все символы до появления левой скобки 
и добавляем их в выходной поток

> Конвертация функции в число

**std::string convertFunc(std::string &str)**

Итерируем строку

Если первый символ является минусом, тогда убираем его и присваиваем отдельному флагу значение, чтобы в конце сделать результат противоположного знака

Оставляем только аргумент внутри функции

Если это константа, то конвертируем ее в число

Передаем аргумент в соответсвующую функцию

Полученный результат возвращаем

> Вычисление выражения

**double calculate(const Stack &postfix)**

Итерируем стек с постфиксной нотацией

Если текущий токен является константой/числом/функций, то помещаем его в стек

Если текущий токен является оператором, тогда достаем из стека последних два токена и производим с ними соответствующие действия

Если нельзя достать токен из стека, тогда выбрасывается исключение о том, что в введенном выражении недостаточно операндов

В конце итераций останется только один токен, который будет являться результатом вычислений

### Examples
> ( ( cos(60) + 1.5 ) - 5 + sin(50) )

Postfix notation: cos(60) 1.5 + 5 - sin(50) +

Calculated value: -4.71479

> Expression: 56 + cos(90) + pi / ctg(30) * ( -ln(9) - cbrt(40) - pi + e )

Postfix notation: 56 cos(90) + pi ctg(30) / -ln(9) cbrt(40) - pi - e + * +

Calculated value: 177.104

> Expression: (2.5+2)*3+1.5

Postfix notation: 2.5 2 + 3 * 1.5 +

Calculated value: 15

> Expression: ( cos(0) + sin(90) )

Postfix notation: cos(0) sin(90) +

Calculated value: 1.894

> Expression: sin(0) / cos(pi) + ( tg(pi) - ctg(999) + ln(e) ) + log(16) * ( sqrt(9) + cbrt(144) )
> 
Postfix notation: sin(0) cos(pi) / tg(pi) ctg(999) - ln(e) + + log(16) sqrt(9) cbrt(144) + * +

Calculated value: 71.7445